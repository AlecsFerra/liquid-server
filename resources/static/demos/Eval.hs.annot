module Eval (eval) where

import Language.Haskell.Liquid.Prelude (liquidError)
import Prelude hiding (lookup)
import Data.Set (Set (..))

data Val  = I Int
          | C Env Bndr Expr  

type Bndr = String 

data Expr = Const Int
          | Var   Bndr
          | Plus  Expr Expr
          | Let   Bndr Expr Expr
          | Lam   Bndr Expr
          | App   Expr Expr
 
type Env  = [(Bndr, Val)]

------------------------------------------------------------------
{-@ lookup :: g:Env -> (InEnv g) -> Val @-}
lookup :: Env -> Bndr -> Val
---------------------  -------------------------------------------
lookup ((y,v):env) x 
  | x == y             = v
  | otherwise          = lookup env x
lookup [] _            = liquidError "Unbound Variable"

------------------------------------------------------------------
{-@ Lazy eval @-}
{-@ eval :: env:Env -> (ClosedExpr env) -> Val @-}
------------------------------------------------------------------

eval env (Const i)     
  = I i

eval env (Var x)       
  = lookup env x 

eval env (Plus e1 e2)  
  = case (eval env e1, eval env e2) of 
      (I n1, I n2) -> I (n1 + n2) 
      _            -> error "Type Error: non-int addition"

eval env (Let x e1 e2) 
  = eval ((x, eval env e1) : env) e2 

eval env (Lam x e)
  = C env x e

eval env (App e1 e2)   
  = case eval env e1 of 
      C env1 x e1' -> eval ((x, eval env e2) : env1) e1'
      _            -> error "Type Error: non-function application"


{-@ type InEnv G      = {v:Bndr | (Set_mem v (vars G))}                              @-}
{-@ type ClosedExpr G = {v:Expr | (Set_sub (free v) (vars G))}                       @-}
{-@ type Closure G X  = {v:Expr | (Set_sub (free v) (Set_cup (vars G) (Set_sng X)))} @-}


{-@ invariant {v:Expr | (esize v) > 0} @-}

{-@ data Val  = I (i::Int)
              | C (g::Env) (x::Bndr) (e::(Closure g x))  
  @-}

{-@ data Expr [esize]
      = Const (i::Int)
      | Var   (x::Bndr)
      | Plus  (s::Expr)  (t::Expr)
      | Let   (x::Bndr)  (s::Expr) (t::Expr)
      | Lam   (x::Bndr)  (t::Expr)
      | App   (s::Expr)  (t::Expr)
  @-}

------------------------------------------------------------------
-- The set of binders in an environment --------------------------
------------------------------------------------------------------

{-@ measure vars :: Env -> (Set Bndr)
    vars ([])    = {v | (Set_emp v) }
    vars (b:env) = {v | v = (Set_cup (Set_sng (fst b)) (vars env))}
  @-}

------------------------------------------------------------------
-- The set of free-vars in an expression -------------------------
------------------------------------------------------------------

{-@ measure free       :: Expr -> (Set Bndr) 
    free (Const i)     = {v | (Set_emp v)}
    free (Var x)       = {v | v = (Set_sng x)} 
    free (Plus e1 e2)  = {v | v = (Set_cup (free e1) (free e2))}
    free (Let x e1 e2) = {v | v = (Set_cup (free e1) (Set_dif (free e2) (Set_sng x)))}
    free (App e1 e2)   = {v | v = (Set_cup (free e1) (free e2))}
    free (Lam x e)     = {v | v = (Set_dif (free e) (Set_sng x))}
  @-}

------------------------------------------------------------------
-- A Size Metric on Expressions ----------------------------------
------------------------------------------------------------------

{-@ measure esize       :: Expr -> Int 
    esize (Var x)       = 1
    esize (Const i)     = 1
    esize (Plus e1 e2)  = (esize e1) + (esize e2)
    esize (Let x e1 e2) = (esize e1) + (esize e2)
  @-}


env
50
7
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


env
53
15
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


e2
54
42
1
{VV : (Eval.Expr) | (VV == e2) && ((esize VV) > 0)}


unknown
43
29
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x + y))}


env
35
6
1
[([(GHC.Types.Char)], (Eval.Val))]


env
42
29
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


unknown
50
5
4
g_Eval.C:[([(GHC.Types.Char)], (Eval.Val))]
-> x_Eval.C:[(GHC.Types.Char)]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (Set_cup (vars g_Eval.C) (Set_sng x_Eval.C))))}
-> (Eval.Val)


Eval.lookup
25
1
3
g:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : [(GHC.Types.Char)] | ((Set_mem VV (vars g)))}
-> (Eval.Val)


unknown
28
26
1
{VV : [(GHC.Types.Char)] | false} -> {VV : (Eval.Val) | false}


e2
47
35
1
{VV : (Eval.Expr) | (VV == e2) && ((esize VV) > 0)}


n2
43
31
1
{VV : (GHC.Types.Int) | (VV == n2)}


eval
53
10
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


env
39
12
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


lq_anf__d1ga
44
29
1
{VV : [(GHC.Types.Char)] | ((len VV) >= 0)}


eval
42
11
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


env
47
20
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


unknown
36
5
1
(GHC.Types.Int) -> (Eval.Val)


unknown
42
10
1
((Eval.Val), (Eval.Val))


eval
35
1
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


eval
47
5
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


x
54
30
1
{VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) >= 0)}


unknown
54
46
4
forall <p :: ([(GHC.Types.Char)], (Eval.Val))-> ([(GHC.Types.Char)], (Eval.Val))-> Bool>.
x:([(GHC.Types.Char)], (Eval.Val))
-> xs:[{VV : ([(GHC.Types.Char)], (Eval.Val))<p x> | true}]<p>
-> {VV : [([(GHC.Types.Char)], (Eval.Val))]<p> | (((null VV)) <=> false) && ((len VV) == (1 + (len xs))) && ((listElts VV) == (Set_cup (Set_sng x) (listElts xs))) && ((vars VV) == (Set_cup (Set_sng (fst x)) (vars xs)))}


v
26
26
1
{VV : (Eval.Val) | (VV == v)}


y
26
10
1
{VV : [(GHC.Types.Char)] | (VV == y) && ((len VV) >= 0)}


lq_anf__d1gt
55
29
1
{VV : [(GHC.Types.Char)] | ((len VV) >= 0)}


unknown
27
26
3
g:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : [(GHC.Types.Char)] | ((Set_mem VV (vars g)))}
-> (Eval.Val)


x
25
20
1
[(GHC.Types.Char)]


lq_anf__d1gv
54
29
1
{VV : ({VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) == (len x)) && ((len VV) >= 0)}, (Eval.Val)) | ((fst VV) == x)}


n1
43
26
1
{VV : (GHC.Types.Int) | (VV == n1)}


i
36
7
1
{VV : (GHC.Types.Int) | (VV == i)}


eval
42
24
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


x
39
16
1
{VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) >= 0)}


e1
47
24
1
{VV : (Eval.Expr) | (VV == e1) && ((esize VV) > 0)}


$dEq
26
7
1
GHC.Classes.Eq [GHC.Types.Char]


x
27
37
1
{VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) >= 0)}


eval
54
33
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


e
50
13
1
{VV : (Eval.Expr) | (VV == e) && ((esize VV) > 0)}


x
26
5
1
{VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) >= 0)}


e1
42
20
1
{VV : (Eval.Expr) | (VV == e1) && ((esize VV) > 0)}


lq_anf__d1gp
47
11
1
{VV : ({VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) == (len x)) && ((len VV) >= 0)}, (Eval.Val)) | ((fst VV) == x)}


env1
54
48
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env1) && ((len VV) >= 0)}


unknown
43
23
1
(GHC.Types.Int) -> (Eval.Val)


unknown
47
28
4
forall <p :: ([(GHC.Types.Char)], (Eval.Val))-> ([(GHC.Types.Char)], (Eval.Val))-> Bool>.
x:([(GHC.Types.Char)], (Eval.Val))
-> xs:[{VV : ([(GHC.Types.Char)], (Eval.Val))<p x> | true}]<p>
-> {VV : [([(GHC.Types.Char)], (Eval.Val))]<p> | (((null VV)) <=> false) && ((len VV) == (1 + (len xs))) && ((listElts VV) == (Set_cup (Set_sng x) (listElts xs))) && ((vars VV) == (Set_cup (Set_sng (fst x)) (vars xs)))}


x
47
12
1
{VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) >= 0)}


eval
54
23
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


x
50
11
1
{VV : [(GHC.Types.Char)] | (VV == x) && ((len VV) >= 0)}


e1
53
19
1
{VV : (Eval.Expr) | (VV == e1) && ((esize VV) > 0)}


unknown
39
5
3
g:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : [(GHC.Types.Char)] | ((Set_mem VV (vars g)))}
-> (Eval.Val)


env
27
33
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


env
54
38
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


e1'
54
54
1
{VV : (Eval.Expr) | ((Set_sub (free VV) (Set_cup (vars env1) (Set_sng x)))) && (VV == e1') && ((esize VV) > 0)}


e2
42
33
1
{VV : (Eval.Expr) | (VV == e2) && ((esize VV) > 0)}


unknown
44
23
1
[(GHC.Types.Char)] -> {VV : (Eval.Val) | false}


env
47
30
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


env
42
16
1
{VV : [([(GHC.Types.Char)], (Eval.Val))] | (VV == env) && ((len VV) >= 0)}


eval
47
15
3
env:[([(GHC.Types.Char)], (Eval.Val))]
-> {VV : (Eval.Expr) | ((Set_sub (free VV) (vars env)))}
-> (Eval.Val)


lq_anf__d1g5
28
38
1
{VV : [(GHC.Types.Char)] | ((len VV) >= 0)}


unknown
55
23
1
[(GHC.Types.Char)] -> {VV : (Eval.Val) | false}


